use std::fs::File;
use std::path::{Path, PathBuf};

use anyhow::{anyhow, Context};
use csv::Trim;
use rust_decimal::Decimal;
use serde::Deserialize;

use crate::tx::{ClientId, Record, TxId};

/// I couldn't get `serde` to deserialize [`Record`] objects directly. According to @BurntSushi,
/// [tagged enums and CSVs don't play nicely][1]. As a workaround, I use `serde` to deserialize
/// `RawRecord`s and then turn those into `Record`s with some handwritten code.
///
/// [1]: https://github.com/BurntSushi/rust-csv/issues/211
#[derive(Deserialize, Debug)]
struct RawRecord {
    r#type: RawRecordType,
    client: ClientId,
    tx: TxId,
    amount: Option<Decimal>,
}

#[derive(Deserialize, Clone, Copy, Debug)]
#[serde(rename_all = "lowercase")]
enum RawRecordType {
    Deposit,
    Withdrawal,
    Dispute,
    Resolve,
    Chargeback,
}

impl TryFrom<RawRecord> for Record {
    type Error = anyhow::Error;

    fn try_from(raw: RawRecord) -> Result<Self, Self::Error> {
        match raw.r#type {
            RawRecordType::Deposit => Ok(Record::Deposit {
                client: raw.client,
                tx: raw.tx,
                amount: raw.amount.ok_or(anyhow!("deposit missing amount"))?,
            }),
            RawRecordType::Withdrawal => Ok(Record::Withdrawal {
                client: raw.client,
                tx: raw.tx,
                amount: raw.amount.ok_or(anyhow!("withdrawal missing amount"))?,
            }),
            RawRecordType::Dispute => Ok(Record::Dispute {
                client: raw.client,
                tx: raw.tx,
            }),
            RawRecordType::Resolve => Ok(Record::Resolve {
                client: raw.client,
                tx: raw.tx,
            }),
            RawRecordType::Chargeback => Ok(Record::Chargeback {
                client: raw.client,
                tx: raw.tx,
            }),
        }
    }
}

/// Parses the named CSV file and returns an iterator that streams one `Record` per row.
///
/// # Performance Note
///
/// Iterators are clumsy to work with. Rust doesn't have an equivalent of Python's `yield` feature,
/// which provides an ergonomic way to create generators. It would be much easier to return a
/// `Vec<Record>`.
///
/// Returning a vector would require reading the whole file into memory, though, which is subpar
/// from a performane standpoint. It wouldn't scale well to 100MB+ CSV files, and it would prevent
/// CSV files from being processed while simultaneously being generated by another process.
pub fn read_records(path: impl AsRef<Path>) -> anyhow::Result<RecordIterator> {
    RecordIterator::new(path.as_ref())
}

pub struct RecordIterator {
    path: PathBuf,
    iter: csv::DeserializeRecordsIntoIter<File, RawRecord>,
}

impl RecordIterator {
    fn new(path: &Path) -> anyhow::Result<Self> {
        let file = csv::ReaderBuilder::new()
            .trim(Trim::All)
            .from_path(path)
            .with_context(|| format!("Could not open {}", path.display()))?;

        Ok(Self {
            path: path.to_path_buf(),
            iter: file.into_deserialize(),
        })
    }
}

impl Iterator for RecordIterator {
    type Item = anyhow::Result<Record>;

    fn next(&mut self) -> Option<Self::Item> {
        Some(
            self.iter
                .next()?
                .with_context(|| format!("Error reading {}", self.path.display()))
                .and_then(Record::try_from),
        )
    }
}
