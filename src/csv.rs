use std::io::Read;

use anyhow::anyhow;
use csv::Trim;
use rust_decimal::Decimal;
use serde::Deserialize;

use crate::db::{ClientId, TxId, Database};

/// Parses the named CSV file and returns an iterator that streams one `Record` per row.
///
/// # Performance Note
///
/// Iterators are clumsy to work with. Rust doesn't have an equivalent of Python's `yield` feature,
/// which provides an ergonomic way to create generators. It would be much easier to return a
/// `Vec<Record>`.
///
/// Returning a vector would require reading the whole file into memory, though, which is subpar
/// from a performane standpoint. It wouldn't scale well to 100MB+ CSV files, and it would prevent
/// CSV files from being processed while simultaneously being generated by another process.
pub fn read<R: Read>(reader: R) -> RecordIterator<R> {
    RecordIterator::new(reader)
}

pub struct RecordIterator<R: Read>(csv::DeserializeRecordsIntoIter<R, RawRecord>);

impl<R: Read> RecordIterator<R> {
    fn new(reader: R) -> Self {
        let reader = csv::ReaderBuilder::new()
            .trim(Trim::All)
            .from_reader(reader);
        Self(reader.into_deserialize())
    }
}

impl<R: Read> Iterator for RecordIterator<R> {
    type Item = anyhow::Result<Record>;

    fn next(&mut self) -> Option<Self::Item> {
        Some(
            self.0
                .next()?
                .map_err(anyhow::Error::from)
                .and_then(Record::try_from),
        )
    }
}

/// One entry from the transaction file.
///
/// # Note
///
/// Currency values are stored as `Decimal`s. Floating point numbers are a bad idea for currency due
/// the errors introduced by their base-2 representation. A float can store `0.50` exactly but not
/// `0.20`, for example.
///
/// Integers could be used if we stored cents instead of dollars. That would be awkward in this
/// program, though, since the specification requires 4 decimal places of precision rather than 2.
/// It also wouldn't translate well to other currencies. Not every currency is divisible into
/// hundredths.
#[derive(Debug)]
pub enum Record {
    /// A deposit into a client's account.
    Deposit {
        client: ClientId,
        tx: TxId,
        amount: Decimal,
    },

    /// A withdrawal from a client's account.
    Withdrawal {
        client: ClientId,
        tx: TxId,
        amount: Decimal,
    },

    /// A dispute of a previous transaction. Funds are held until the dispute is resolved or charged
    /// back.
    Dispute { client: ClientId, tx: TxId },

    /// Resolves a previous dispute, lifting the hold.
    Resolve { client: ClientId, tx: TxId },

    /// Resolves a previous dispute by withdrawing held funds and freezing the client's account.
    Chargeback { client: ClientId, tx: TxId },
}

impl Record {
    pub fn apply(&self, db: &mut Database) -> anyhow::Result<()> {
        match *self {
            Record::Deposit {
                client: client_id,
                tx: tx_id,
                amount,
            } => db.deposit(client_id, tx_id, amount),

            Record::Withdrawal {
                client: client_id,
                tx: tx_id,
                amount,
            } => db.withdraw(client_id, tx_id, amount),

            Record::Dispute {
                client: client_id,
                tx: tx_id,
            } => db.dispute(client_id, tx_id),

            Record::Resolve {
                client: client_id,
                tx: tx_id,
            } => db.resolve(client_id, tx_id),

            Record::Chargeback {
                client: client_id,
                tx: tx_id,
            } => db.chargeback(client_id, tx_id),
        }
    }
}

/// I couldn't get `serde` to deserialize [`Record`] objects directly. According to @BurntSushi,
/// [tagged enums and CSVs don't play nicely][1]. As a workaround, I use `serde` to deserialize
/// `RawRecord`s and then turn those into `Record`s with some handwritten code.
///
/// [1]: https://github.com/BurntSushi/rust-csv/issues/211
#[derive(Deserialize, Debug)]
struct RawRecord {
    r#type: RawRecordType,
    client: ClientId,
    tx: TxId,
    amount: Option<Decimal>,
}

#[derive(Deserialize, Clone, Copy, Debug)]
#[serde(rename_all = "lowercase")]
enum RawRecordType {
    Deposit,
    Withdrawal,
    Dispute,
    Resolve,
    Chargeback,
}

impl TryFrom<RawRecord> for Record {
    type Error = anyhow::Error;

    fn try_from(raw: RawRecord) -> Result<Self, Self::Error> {
        match raw.r#type {
            RawRecordType::Deposit => Ok(Record::Deposit {
                client: raw.client,
                tx: raw.tx,
                amount: raw.amount.ok_or(anyhow!("deposit missing amount"))?,
            }),
            RawRecordType::Withdrawal => Ok(Record::Withdrawal {
                client: raw.client,
                tx: raw.tx,
                amount: raw.amount.ok_or(anyhow!("withdrawal missing amount"))?,
            }),
            RawRecordType::Dispute => Ok(Record::Dispute {
                client: raw.client,
                tx: raw.tx,
            }),
            RawRecordType::Resolve => Ok(Record::Resolve {
                client: raw.client,
                tx: raw.tx,
            }),
            RawRecordType::Chargeback => Ok(Record::Chargeback {
                client: raw.client,
                tx: raw.tx,
            }),
        }
    }
}

